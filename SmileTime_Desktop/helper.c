#include "helper.h"

char* strstp(char * str, char * stp, int * size){
	char * loc = strstr(str, stp);
	*size = loc-str+1;
	char * retstr = malloc(*size);
	memset(retstr, 0, *size);
	strncpy(retstr, str, *size-1);
	retstr[*size-1] = '\0';
	return retstr;
}

//sends to multiple TCP peers
int ywrite(HTTP_packet* np){
	int i = 0;
	int ret = 0;
	for(;i < numPeers; i++){
		if(peer_fd[i] != -1){
			ret = send(peer_fd[i], np->message, np->length, 0);
			if(ret == -1){
				perror("send");
				exit(1);
			}
		}
	}
	return ret;
}

//reads from a single tcp peer
int yread(HTTP_packet* np, int fd){
	int ret = 0;
	ret = recv(fd, np->message, np->length, 0);
	if(ret == -1){
		perror("write");
		exit(1);
	}
	return ret;
}

//sends to multiple UDP peers
int xwrite(HTTP_packet* np, int fd, int port){
	int ret = 0;
	int i = 0;
	for(; i < numPeers; i ++)
	{
		peer_info[i].sin_port = htons(port);
  		ret = sendto(fd, np->message, np->length, 0, (struct sockaddr *)&peer_info[i], sizeof(struct sockaddr_in));
		if(ret == -1){
			perror("write");
			exit(1);
		}
	}
	return ret;
}

//reads from multiple peers (this probably won't work.)
int xread(HTTP_packet* np){
	int ret = 0;
	int i = 0;
	int sockaddr_storage_size = sizeof(struct sockaddr_storage);
	for(; i < numPeers; i ++)
	{
		ret = recvfrom(peer_fd[i], np->message, np->length, 0, (struct sockaddr *)&peer_info[i], &sockaddr_storage_size);
		if(ret == -1){
			perror("write");
			exit(1);
		}
	}
	return ret;
}

// This function should add a users sockaddr_in if we don't have it already
// and also add it
// Jon, should peer_info be sockaddr_in?
void add_user(struct sockaddr_in user){
/*
	int i = 0;
	for(; i < numPeers; i ++)
	{
		if(peer_fd[i] != -1){
			if(strcmp(inet_ntoa(peer_info[i].sin_addr),inet_ntoa(user.sin_addr))==0){
				// Here, we've found the user already collected
				return
			}
		} else {
			// At this point we should open up a udp socket for the user and save the sockaddr_in info
		}
	}
*/
}

int strToInt(char* str){
	int i = 0;
	int ret = 0;
	while(str[i] != '\0'){
		ret *= 10;
		ret += str[i] - '0';
		i++;
	}
	return ret;
}


  char jpgHdr[] =
  {
	0xff,0xd8,				  // SOI
	0xff,0xe0,				  // APP0
	0x00,0x10,				  // APP0 Hdr size
	0x4a,0x46,0x49,0x46,0x00, // ID string
	0x01,0x01,				  // Version
	0x00,					  // Bits per type
	0x00, 0x00,				  // X density
	0x00, 0x00,				  // Y density
	0x00,					  // X Thumbnail size
	0x00					  // Y Thumbnail size
  };

  char MJPGDHTSeg[0x1A4] =
  {
	 /* JPEG DHT Segment for YCrCb omitted from MJPG data */
	0xFF,0xC4,0x01,0xA2,
	0x00,0x00,0x01,0x05,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x01,0x00,0x03,0x01,0x01,0x01,0x01,
	0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
	0x08,0x09,0x0A,0x0B,0x10,0x00,0x02,0x01,0x03,0x03,0x02,0x04,0x03,0x05,0x05,0x04,0x04,0x00,
	0x00,0x01,0x7D,0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,
	0x07,0x22,0x71,0x14,0x32,0x81,0x91,0xA1,0x08,0x23,0x42,0xB1,0xC1,0x15,0x52,0xD1,0xF0,0x24,
	0x33,0x62,0x72,0x82,0x09,0x0A,0x16,0x17,0x18,0x19,0x1A,0x25,0x26,0x27,0x28,0x29,0x2A,0x34,
	0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x53,0x54,0x55,0x56,
	0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x73,0x74,0x75,0x76,0x77,0x78,
	0x79,0x7A,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,
	0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,
	0xBA,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,
	0xDA,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,
	0xF8,0xF9,0xFA,0x11,0x00,0x02,0x01,0x02,0x04,0x04,0x03,0x04,0x07,0x05,0x04,0x04,0x00,0x01,
	0x02,0x77,0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,
	0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,0xA1,0xB1,0xC1,0x09,0x23,0x33,0x52,0xF0,0x15,0x62,
	0x72,0xD1,0x0A,0x16,0x24,0x34,0xE1,0x25,0xF1,0x17,0x18,0x19,0x1A,0x26,0x27,0x28,0x29,0x2A,
	0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x53,0x54,0x55,0x56,
	0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x73,0x74,0x75,0x76,0x77,0x78,
	0x79,0x7A,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98,
	0x99,0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,
	0xB9,0xBA,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,
	0xD9,0xDA,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,
	0xF9,0xFA
  };

int mjpeg2Jpeg(char **jpg, const char *mjpg, const int size)
{
  //removing avi header
  int tmp = *(mjpg + 4);
  tmp <<= 8;
  tmp += *(mjpg + 5) + 4;

	int newSize = sizeof (jpgHdr) + sizeof (MJPGDHTSeg) + size - tmp;
	*jpg = malloc(newSize);
	memcpy(*jpg, jpgHdr, sizeof(jpgHdr));
	memcpy(*jpg + sizeof(jpgHdr), MJPGDHTSeg, sizeof(MJPGDHTSeg));
	memcpy(*jpg + sizeof(jpgHdr) + sizeof(MJPGDHTSeg), mjpg+tmp, size - tmp);

	return newSize;
}
